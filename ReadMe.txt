Лебедв Петр АНдреевич БПИ 217 На 9 баллов
Задача об инвентаризации по книгам. После нового года в
библиотеке университета обнаружилась пропажа каталога. После
поиска и наказания, виноватых ректор дал указание восстановить
каталог силами студентов. Фонд библиотека представляет собой
прямоугольное помещение, в котором находится M рядов по N шкафов по K книг в каждом шкафу. Требуется создать приложение, составляющее каталог. При решении задачи в качестве
отдельного процесса задается внесение в каталог записи об отдельной книге, которая сразу ставится на место в соответствии с выбранным методом упорядочения каталога. Примечание. Каталог —
это список книг, упорядоченный по их инвентарному номеру или
по алфавиту (на выбор разработчика). Каждая строка каталога содержит идентифицирующее значение (номер или название),
номер ряда, номер шкафа, номер книги в шкафу.

Как устроены программы на 4-6:
Аргумнты командной строки: 10 чисел (уникальные номера книг на складе)
Каждый дочерний процесс берет 1 книгу со склада и ставит ее в нужное место в каталоге
Дочерние процессы создаются при помощи форков, доступ к памяти ограничивается семафорами.

Как устроены программы на 7-8:
Сначала создается главный процесс( _main.out) он каждую секунду выводит текущий каталог книг
вы можете создавать сколько угодно файлов _agent.out с 1 числом в аргументах. 
Число это уникальный айди по которому сортируется каталог. ПОсле ввода числа ваш процесс ставит книгу на место в каталог.
Каталог все также хранится в разделяемой памяти, доступ к нему ограничивают семафоры. 

В программе на 9 баллов(реализовал через пайпы) роль главного и потока-агента сохранены.
Но теперь главный процесс получает доступ к пайпу без семафора. Так как чтобя читать из пайпа нужно чтобы он был открыт на чтение и запись, 
а при блокировки семафором главного процесса возникает ошибка взаимной блокировки ресурсов(дедлок). 
Мейн занял семафор и ждет когда откроется пайп на запись, процесс-агент ждет когда откроется семафор чтобы открыть пайп на запись.
Но семафоры я все равно использую, чтобы контролировать доступ к разделяемой памяти у нескольких процессов-агентов.
(Вдруг кто то решит запустить 10 программ разом)
